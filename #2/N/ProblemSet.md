# N

## 题目描述

### Background
　　话说凡间有一位英俊的青年牧羊人，名叫Nix，深得月亮女神露娜的青睐。但是她和凡人之间的爱情不被众神接受，因为月亮女神必须守身如玉，才能履行好职责。因此天公朱庇特要求Nix，在死亡和永葆青春的沉睡间任选其一。Nix最终为爱选择了后者。

　　Nix陷入沉睡后的998244353年后： 

　　太阳之神索尔出现在了Nix的床边，他想帮助这个执着于爱情的年轻人，但又不能让朱庇特发现。于是他在Nix的梦境中设置了一道难关，只要Nix突破这道难关，就能蒙蔽天机，从沉睡中醒来，并与女神相逢。

　　作为Nix的好朋友你，当然要帮助沉睡了这么多年，脑子已经秀逗了的Nix突破这道难关。

### Description
　　索尔有$n×m$匹神马来驾驶他的太阳马车，这些马构成了一个矩形。每天早上，这些马要么躺着，要么站着，索尔希望让这些马都站起来，因为这样可以让他法力无边。由于索尔的神力过于强大，当他命令一匹马改变状态时（躺着变为站着，站着变为躺着），和这匹马站在同一行的马都会改变一次状态，和这匹马站在同一列的马也都会改变一次状态。索尔希望看到Nix的机智，所以他问Nix最少需要几次命令可以让马都站起来。

　　** 简单来说 **，你有一个$0/1$矩阵，每次你都可以让一个数字改变状态（从0变成1，从1变成0），该操作也会使得和这个数字在同一行的其他点改变状态，和这个数字在同一列的其他点改变状态，你需要输出最少的操作次数使得整个矩阵变为全0。

## 输入格式

第一行包含五个整数$n,m,a,b,Mod$表示矩阵的大小  **（数据保证n,m都是偶数）**

由于数据规模过大，你可以使用以下方法来生成数据

```cpp
long long num=a;
for (int i=1;i<=n;i++)
	for (int j=1;j<=m;j++)
	{
		num=(num*b%Mod+a)%Mod;
		Matrix[i][j]=(num&1);
	}
```

## 输出格式

** 第零行必须输出“FKC AK IOI 2019!” **

第一行一个整数$t$，表示最少的操作数（数据保证有解）

## 样例

### Input
```plain
4 4 7 5 19
```
### Output
```plain
FKC AK IOI 2019!
6
```

## 数据范围与提示

### 提示

别忘了输出第0行，否则你将获得0分的好成绩

样例数据的矩阵
```plain
0 0 1 0 
1 0 0 0 
1 0 0 1 
0 1 0 0 
```
你可以按顺序改变下列点的状态来得到答案
``` plain
(1,1)
(1,3)
(3,1)
(3,2)
(3,3)
(4,1)
(4,2)
```
### 数据范围
Subtask | 分值 | n,m$\leq$ | 其他限制
 :-: | :-: | :-: |  :-:
1 | 10 | 0         |
2 | 10 | 4         |
3 | 20 | 10       |
3 | 20 | 100     | 
4 | 40 | 5000 |

